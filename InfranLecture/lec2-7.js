// ★ 봉우리 문제
/*
    - 문제 1 : N*N 격자판이 주어지면 각 행의 합, 열의 합, 두 대각선의 합 중 가장 큰 값을 출력하는 코드를 작성하시오.
    - 조건 1 : 첫 줄에는 N이 주어집니다.
    - 조건 2 : 두번째 줄에는 각 줄에 N개의 자연수가 주어집니다.
    - 조건 3 : 각 자연수는 100을 넘기지 않습니다.

*/

function solution(arr){  
    let answer=0;
    let n=arr.length;
    let dx=[-1, 0, 1, 0];
    let dy=[0, 1, 0, -1];
    // 현재 좌표에서 x좌표와 y좌표를 동서남북 네 방향으로 이동시킬 배열을 각각 만들어줍니다.
    for(let i=0; i<n; i++){
        for(let j=0; j<n; j++){
            let flag = true;
            // 봉우리가 맞는지의 여부의 flag 변수를 true로 초기화 합니다.
            for(let k=0; k<4; k++){
            // k를 0부터 3까지, 즉 동서남북 배열을 각각 이동시킬 for문을 하나 만들어줍니다.
                let nx=i+dx[k];
                let ny=j+dy[k];
                //각각 nx와 ny변수(현재 위치에서 n만큼 이동한 값을 담기 위한 변수)에 현재 위치에서 각각의 시계 방향(dx와 dy)으로 이동한 값을 넣어줍니다.
                if((nx>=0 && nx<n && ny>=0 && ny<n) && (arr[nx][ny]>=arr[i][j])){
                    flag = false;
                    break;
                // 만약 시계 방향의 봉우리의 높이가 현재 위치보다 크거나 같을 경우 flag를 false로 할당 후 해당 k for문을 완전히 종료합니다.
                // 이때 첫번째 조건문 괄호의 의미는 시계방향으로 위치한 좌표가 배열, 즉 테이블의 좌표에서 - 좌표로 벗어나지 않은 상태이거나 (>=0), 그 반대로 n의 범위를 초과한 상태(<n) 가 아닐 경우, 즉 사분면에 온전한 숫자가 있는 상태에서의 다음 조건식을 비교하게 되며 그렇지 않을 경우 out of range가 되기 때문에 error가 발생됩니다.
                }
            }
            if(flag) answer++;
            // flag가 참이면, 즉 해당 위치가 사면보다 높은 봉우리라면 answer를 증가시킵니다.
        }
    }  
// 설명 추가 완료
    return answer;
}

let arr=[[5, 3, 7, 2, 3], 
         [3, 7, 1, 6, 1],
         [7, 2, 5, 3, 4],
         [4, 3, 6, 4, 1],
         [8, 7, 3, 5, 2]];
console.log(solution(arr));