// ★ 문자거리 문제 
/*
    - 문제 1 : 한 개의 문자열 s와 문자 t가 주어지면 문자열 s의 각 문자가 문자 t와 떨어진 최소거리를 출력하는 코드를 작성하시오.
    - 조건 1 : 문자열과 문자는 소문자로만 주어집니다.
    - 조건 2 : 문자열의 길이는 100 이하입니다.
*/

function solution(s, t){
    let answer=[];
    // 정답을 받을 배열 하나를 선언합니다.
    let p = 1000;
    // p에 1000을 저장합니다. 물론 Number.MAX_SAFE_INTEGER를 사용할 수 있으나 이럴 경우 1만 더해도 오버플로우 현상으로 음수가 되기 때문에 그냥 1000을 더합니다.
    for(let x of s){
    // for of로 넘어온 배열을 돌리는데, 이때의 for of문은 왼쪽에서 오른쪽으로 가는 상태입니다.
        if(x===t){
        // 만약 넘어온 배열(s)의 현재 인자(x) 가 찾는 문자(t)와 같다면, 즉 배열의 현재 문자가 기준이 되는 문자와 같은 경우입니다.
            p=0;
        // p를 0으로 선언 후
            answer.push(p);
        // answer 배열에 p의 값을 담아줍니다. 그래서 기준이 되는 문자를 찾을시 0이 대입됩니다.
        }else{
        // 그게 아니라면 
            p++
        // p의 값을 증가시킨 후
            answer.push(p);
        // 그 값을 answer 배열에 push 해줍니다.
        }
    }
    p = 1000;
    // 이제 다시 p를 1000으로 초기화 해준 후
    for(let i = s.length-1 ; i>=0 ; i--){
    // 넘어온 배열의 맨 뒷자리부터 한자리씩 감소하며 도는 for문을 선언한 후
        if(s[i] === t){
        // 만약 넘어온 배열의 맨 뒷자리 기준 문자와 같다면 
            p=0;
        // p를 0으로 초기화 후 
            answer.push(p);
        // answer에 담고 
        }else{
            p++
        //그게 아니라면 p를 증가시킨 후 
            answer[i]=Math.min(answer[i]. p);
        // answer의 i번쨰에 담는데, answer의 i번째(for of에서 할당했던 그때 당시 p의 값)과 현재의 p의 값과 비교하여 현재의 p 값이 작은 경우,
        // 즉 전에 기준이 되었던 t로부터 떨어져 있던 값과 현재 t로부터 떨어져 있는 값을 비교하여 작은 값을 answer의 현재 i번째 값에 할당합니다.
        // 만약 특정 인덱스에서 전에 있던 t(왼쪽)로부터 떨어져 있는 값이 3, 현재 t(오른쪾)로부터 떨어져 있는 값이 2라고 한다면 오른쪽 t의 값에 더 가깝기 때문에 오른쪽 t를 기준으로 떨어져있는 2를 할당하게 되는 것입니다.
        }
    }

    return answer;
    // 이후 for문이 끝나면 answer 배열을 반환합니다.
}

let str="teachermode";
console.log(solution(str, 'e'));
